# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'gui.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from PyQt5.QtWidgets import QApplication, QMainWindow, QWidget, QSlider, QLabel, QVBoxLayout, QHBoxLayout, QFrame, \
    QPushButton, QFileDialog, QMessageBox
from PyQt5.QtCore import Qt, QThread, pyqtSignal
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtGui import QImage, QPixmap, QColor, QTextCharFormat
from PyQt5.QtWidgets import QProgressDialog
from mainwindow import Ui_mainWindow
from PyQt5.QtCore import QCoreApplication
import time
from functools import partial
import asyncio
import sys
import importlib.util
#   pyuic5 -o  mainwindow.py mainwindow.ui

from pydantic import BaseModel

from src.imecas_auto_reconnect.configs import get_settings, SettingsManager
from src.imecas_auto_reconnect.login_manager import login_async


class LoginThread(QThread):
    update_signal = pyqtSignal(str)

    def __init__(self, interval_minutes, headless=None):
        super().__init__()
        self.interval_minutes = interval_minutes
        self.is_running = True
        self.headless = headless

    def run(self):
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        loop.run_until_complete(self.login_loop())

    async def login_loop(self):
        while self.is_running:
            try:
                await login_async(self.headless)
                self.update_signal.emit("登录成功")
            except Exception as e:
                self.update_signal.emit(f"登录失败: {str(e)}")
            await asyncio.sleep(self.interval_minutes * 60)

    def stop(self):
        self.is_running = False

class ClientSettings(BaseModel):
    headless: bool
    reconnect_interval_minutes: int

class CustomForm(QMainWindow, Ui_mainWindow):

    def __init__(self):
        super().__init__()
        self.setupUi(self)
        try:
            self.startButton.clicked.disconnect()
        except TypeError:
            pass
        self.startButton.clicked.connect(self.on_start_button_clicked)
        self.login_thread = None
        self.is_running = False



    def retrieve_client_settings(self) -> ClientSettings:
        interval = int(self.runningIntervalCombo.currentText())
        headless = self.headlessCombo.currentText() == "是"
        return ClientSettings(headless=headless, reconnect_interval_minutes=interval)

    def on_start_button_clicked(self):
        self.insert_text("开始修改配置", "green")
        self.modify_settings()
        self.insert_text("开始安装依赖", "green")
        self.install_requirements()
        self.insert_text("开始启动任务", "green")
        if not self.is_running:
            self.start_task()
            self.startButton.setText("终止")
            self.is_running = True
        else:
            self.stop_task()
            self.startButton.setText("启动")
            self.is_running = False


    def modify_settings(self):
        settings_manager = SettingsManager()

        settings_manager.update_settings(HEAD_LESS=self.retrieve_client_settings().headless,
                                RECONNECT_INTERVAL_MINUTES=self.retrieve_client_settings().reconnect_interval_minutes)
        self.insert_text("修改配置完成, 已保存", "green")

    def install_requirements(self):
        self.progress_dialog = QProgressDialog("正在安装依赖...", "取消", 0, 100, self)
        self.progress_dialog.setWindowModality(Qt.WindowModal)
        self.progress_dialog.setWindowTitle("安装进度")
        self.progress_dialog.show()

        try:
            # 创建事件循环
            self.loop = asyncio.get_event_loop()
            self.loop.run_until_complete(self.ensure_playwright_browsers())
        except Exception as e:
            self.insert_text(f"安装过程中发生错误: {str(e)}", "red")
        finally:
            if self.progress_dialog:
                self.progress_dialog.close()

    async def run_command(self, cmd):
        process = await asyncio.create_subprocess_exec(
            *cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )

        async def read_stream(stream):
            while True:
                line = await stream.readline()
                if line:
                    self.insert_text(line.decode().strip(), "blue")
                    self.progress_dialog.setValue(self.progress_dialog.value() + 1)
                    QApplication.processEvents()
                else:
                    break

        await asyncio.gather(
            read_stream(process.stdout),
            read_stream(process.stderr)
        )

        return await process.wait()

    async def install_package(self, package):
        self.insert_text(f"正在安装 {package}...", "green")
        cmd = [sys.executable, "-m", "pip", "install", package]
        return await self.run_command(cmd)

    async def install_playwright_browsers(self):
        self.insert_text("正在检查并安装必要的浏览器...", "green")
        cmd = [sys.executable, "-m", "playwright", "install"]
        return await self.run_command(cmd)

    async def ensure_playwright_browsers(self):
        if importlib.util.find_spec("playwright") is None:
            self.insert_text("Playwright 未安装。正在安装 Playwright...", "green")
            result = await self.install_package("playwright")
            if result != 0:
                self.insert_text("安装 Playwright 时出错", "red")
                self.progress_dialog.close()
                return

        result = await self.install_playwright_browsers()
        if result != 0:
            self.insert_text("安装浏览器时出错", "red")
            self.progress_dialog.close()
            return

        self.insert_text("浏览器安装完成。", "green")
        self.progress_dialog.close()

    def start_task(self):
        self.insert_text("开始修改配置", "green")
        self.modify_settings()
        self.insert_text("开始安装依赖", "green")
        self.install_requirements()
        self.insert_text("开始启动任务", "green")
        if self.login_thread is None or not self.login_thread.isRunning():
            interval = int(self.runningIntervalCombo.currentText())
            headless = self.headlessCombo.currentText() == "是"
            self.login_thread = LoginThread(interval, headless)
            self.login_thread.update_signal.connect(self.update_output)
            self.login_thread.start()
            self.insert_text(f"登录任务已启动，每 {interval} 分钟执行一次", "green")
        else:
            self.insert_text("登录任务已在运行中", "red")

    def update_output(self, message):
        self.insert_text(message, "blue")

    def stop_task(self):
        if self.login_thread and self.login_thread.isRunning():
            self.login_thread.stop()
            self.login_thread.wait()
            self.insert_text("登录任务已终止", "green")
        else:
            self.insert_text("没有正在运行的任务", "red")

    def closeEvent(self, event):
        self.stop_task()
        super().closeEvent(event)


    def insert_text(self, text: str, color: str):
        if color == "green":
            color = QColor(0, 255, 0)
        elif color == "red":
            color = QColor(255, 0, 0)
        elif color == "blue":
            color = QColor(0, 0, 255)
        else:
            color = QColor(0, 0, 0)
        text += "\n"
        cursor = self.outputEditText.textCursor()
        format = QTextCharFormat()
        format.setForeground(color)
        cursor.insertText(text, format)
        cursor.movePosition(cursor.End)
        self.outputEditText.setTextCursor(cursor)
        self.outputEditText.ensureCursorVisible()
