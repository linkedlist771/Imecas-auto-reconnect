# -*- coding: utf-8 -*-
import subprocess

# Form implementation generated from reading ui file 'gui.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from PyQt5.QtWidgets import QApplication, QMainWindow, QWidget, QSlider, QLabel, QVBoxLayout, QHBoxLayout, QFrame, \
    QPushButton, QFileDialog, QMessageBox
from PyQt5.QtCore import Qt, QThread, pyqtSignal
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtGui import QImage, QPixmap, QColor, QTextCharFormat
from PyQt5.QtWidgets import QProgressDialog
from mainwindow import Ui_mainWindow
from PyQt5.QtCore import QCoreApplication
import time
from functools import partial
import asyncio
import sys
import importlib.util
#   pyuic5 -o  mainwindow.py mainwindow.ui

from pydantic import BaseModel

from configs import get_settings, SettingsManager
from login_manager import login_async

login_counts = 0

class LoginThread(QThread):
    update_signal = pyqtSignal(str)

    def __init__(self, interval_minutes, headless=None):
        super().__init__()
        self.interval_minutes = interval_minutes
        self.is_running = True
        self.headless = headless

    def run(self):
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        loop.run_until_complete(self.login_loop())

    async def login_loop(self):
        while self.is_running:
            try:
                global login_counts
                login_counts += 1
                self.update_signal.emit(f"第 {login_counts} 次登录")
                await login_async(self.headless)
                self.update_signal.emit("登录成功")
            except Exception as e:
                self.update_signal.emit(f"登录失败: {str(e)}")
            await asyncio.sleep(self.interval_minutes * 60)

    def stop(self):
        self.is_running = False


class InstallThread(QThread):
    update_signal = pyqtSignal(str)
    progress_signal = pyqtSignal(int)
    finished_signal = pyqtSignal()

    def run(self):
        self.ensure_playwright_browsers()
        self.finished_signal.emit()

    def run_command(self, cmd):
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            universal_newlines=True
        )

        for line in process.stdout:
            self.update_signal.emit(line.strip())
            self.progress_signal.emit(1)

        return process.wait()

    def install_package(self, package):
        self.update_signal.emit(f"正在安装 {package}...")
        cmd = [sys.executable, "-m", "pip", "install", package]
        return self.run_command(cmd)

    def install_playwright_browsers(self):
        self.update_signal.emit("正在检查并安装必要的浏览器...")
        cmd = [sys.executable, "-m", "playwright", "install"]
        return self.run_command(cmd)

    def ensure_playwright_browsers(self):
        if importlib.util.find_spec("playwright") is None:
            self.update_signal.emit("Playwright 未安装。正在安装 Playwright...")
            result = self.install_package("playwright")
            if result != 0:
                self.update_signal.emit("安装 Playwright 时出错")
                return

        result = self.install_playwright_browsers()
        if result != 0:
            self.update_signal.emit("安装浏览器时出错")
            return

        self.update_signal.emit("浏览器安装完成。")

class ClientSettings(BaseModel):
    headless: bool
    reconnect_interval_minutes: int

class CustomForm(QMainWindow, Ui_mainWindow):

    def __init__(self):
        super().__init__()
        self.setupUi(self)
        try:
            self.startButton.clicked.disconnect()
        except TypeError:
            pass
        self.startButton.clicked.connect(self.on_start_button_clicked)
        self.login_thread = None
        self.is_running = False
        self.install_thread = None



    def retrieve_client_settings(self) -> ClientSettings:
        interval = int(self.runningIntervalCombo.currentText())
        headless = self.headlessCombo.currentText() == "是"
        return ClientSettings(headless=headless, reconnect_interval_minutes=interval)

    def on_start_button_clicked(self):
        self.insert_text("开始修改配置", "green")
        self.modify_settings()
        self.insert_text("开始安装依赖", "green")
        self.install_requirements()
        self.insert_text("开始启动任务", "green")
        if not self.is_running:
            self.start_task()
            self.startButton.setText("终止")
            self.is_running = True
        else:
            self.stop_task()
            self.startButton.setText("启动")
            self.is_running = False


    def modify_settings(self):
        settings_manager = SettingsManager()

        settings_manager.update_settings(HEAD_LESS=self.retrieve_client_settings().headless,
                                RECONNECT_INTERVAL_MINUTES=self.retrieve_client_settings().reconnect_interval_minutes)
        self.insert_text("修改配置完成, 已保存", "green")

    def install_requirements(self):
        self.insert_text("正在检查并安装必要的浏览器...", "blue")
        self.ensure_playwright_browsers()
        self.insert_text("依赖安装完成", "green")

    def run_command(self, cmd):
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            universal_newlines=True
        )

        for line in process.stdout:
            self.insert_text(line.strip(), "blue")

        return process.wait()

    def install_package(self, package):
        self.insert_text(f"正在安装 {package}...", "blue")
        cmd = [sys.executable, "-m", "pip", "install", package]
        return self.run_command(cmd)

    def install_playwright_browsers(self):
        self.insert_text("正在检查并安装必要的浏览器...", "blue")
        cmd = [sys.executable, "-m", "playwright", "install"]
        return self.run_command(cmd)

    def ensure_playwright_browsers(self):
        if importlib.util.find_spec("playwright") is None:
            self.insert_text("Playwright 未安装。正在安装 Playwright...", "blue")
            result = self.install_package("playwright")
            if result != 0:
                self.insert_text("安装 Playwright 时出错", "red")
                return

        result = self.install_playwright_browsers()
        if result != 0:
            self.insert_text("安装浏览器时出错", "red")
            return

        self.insert_text("浏览器安装完成。", "green")

    def start_task(self):
        self.insert_text("开始修改配置", "green")
        self.modify_settings()
        self.insert_text("开始安装依赖", "green")
        self.install_requirements()
        self.insert_text("开始启动任务", "green")
        if self.login_thread is None or not self.login_thread.isRunning():
            interval = int(self.runningIntervalCombo.currentText())
            headless = self.headlessCombo.currentText() == "是"
            self.login_thread = LoginThread(interval, headless)
            self.login_thread.update_signal.connect(self.update_output)
            self.login_thread.start()
            self.insert_text(f"登录任务已启动，每 {interval} 分钟执行一次", "green")
        else:
            self.insert_text("登录任务已在运行中", "red")

    def update_output(self, message):
        self.insert_text(message, "blue")

    def stop_task(self):
        if self.login_thread and self.login_thread.isRunning():
            self.login_thread.stop()
            self.login_thread.wait()
            self.insert_text("登录任务已终止", "green")
        else:
            self.insert_text("没有正在运行的任务", "red")

    def closeEvent(self, event):
        self.stop_task()
        super().closeEvent(event)


    def insert_text(self, text: str, color: str):
        if color == "green":
            color = QColor(0, 255, 0)
        elif color == "red":
            color = QColor(255, 0, 0)
        elif color == "blue":
            color = QColor(0, 0, 255)
        else:
            color = QColor(0, 0, 0)
        text += "\n"
        cursor = self.outputEditText.textCursor()
        format = QTextCharFormat()
        format.setForeground(color)
        cursor.insertText(text, format)
        cursor.movePosition(cursor.End)
        self.outputEditText.setTextCursor(cursor)
        self.outputEditText.ensureCursorVisible()
